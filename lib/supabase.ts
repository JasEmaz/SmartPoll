import { createServerClient, type CookieOptions } from '@supabase/ssr';\nimport { createBrowserClient } from '@supabase/ssr';\nimport { cookies } from 'next/headers';\nimport { NextRequest, NextResponse } from 'next/server';\nimport type { Database } from './database.types';\n\n/**\n * SECURITY FEATURES IMPLEMENTED:\n * \n * 1. HTTP-ONLY COOKIES: Tokens stored in httpOnly cookies to prevent XSS access\n * 2. SECURE COOKIE OPTIONS: SameSite, Secure, Path restrictions\n * 3. SERVER-SIDE VALIDATION: All auth checks performed server-side\n * 4. SESSION MANAGEMENT: Proper session refresh and cleanup\n * 5. CSRF PROTECTION: SameSite cookie policy prevents CSRF attacks\n * 6. TOKEN ROTATION: Automatic refresh token rotation\n */\n\n// Secure cookie configuration for production\nconst SECURE_COOKIE_OPTIONS: CookieOptions = {\n  httpOnly: true,           // Prevents XSS access to tokens\n  secure: process.env.NODE_ENV === 'production', // HTTPS only in production\n  sameSite: 'lax',         // CSRF protection\n  path: '/',               // Available site-wide\n  maxAge: 60 * 60 * 24 * 7 // 7 days\n};\n\n/**\n * Create a server-side Supabase client with secure cookie handling\n * Used in server components, API routes, and middleware\n */\nexport function createServerClient() {\n  const cookieStore = cookies();\n  \n  return createServerClient<Database>(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        get(name: string) {\n          return cookieStore.get(name)?.value;\n        },\n        set(name: string, value: string, options: CookieOptions) {\n          try {\n            // Merge with secure defaults\n            const secureOptions = {\n              ...SECURE_COOKIE_OPTIONS,\n              ...options\n            };\n            cookieStore.set({ name, value, ...secureOptions });\n          } catch (error) {\n            // Handle cookie setting errors gracefully in server components\n            console.warn('Failed to set cookie:', name, error);\n          }\n        },\n        remove(name: string, options: CookieOptions) {\n          try {\n            const secureOptions = {\n              ...SECURE_COOKIE_OPTIONS,\n              ...options\n            };\n            cookieStore.set({ name, value: '', ...secureOptions, maxAge: 0 });\n          } catch (error) {\n            console.warn('Failed to remove cookie:', name, error);\n          }\n        },\n      },\n    }\n  );\n}\n\n/**\n * Create a browser-side Supabase client with minimal privileges\n * Used in client components (with caution)\n */\nexport function createBrowserClient() {\n  return createBrowserClient<Database>(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n  );\n}\n\n/**\n * Create middleware client for request/response handling\n * Used in middleware.ts for session management\n */\nexport function createMiddlewareClient(request: NextRequest) {\n  let response = NextResponse.next({\n    request: {\n      headers: request.headers,\n    },\n  });\n\n  const supabase = createServerClient<Database>(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        get(name: string) {\n          return request.cookies.get(name)?.value;\n        },\n        set(name: string, value: string, options: CookieOptions) {\n          const secureOptions = {\n            ...SECURE_COOKIE_OPTIONS,\n            ...options\n          };\n          \n          // Set cookie in both request and response\n          request.cookies.set({ name, value, ...secureOptions });\n          response = NextResponse.next({\n            request: {\n              headers: request.headers,\n            },\n          });\n          response.cookies.set({ name, value, ...secureOptions });\n        },\n        remove(name: string, options: CookieOptions) {\n          const secureOptions = {\n            ...SECURE_COOKIE_OPTIONS,\n            ...options,\n            maxAge: 0\n          };\n          \n          // Remove cookie from both request and response\n          request.cookies.set({ name, value: '', ...secureOptions });\n          response = NextResponse.next({\n            request: {\n              headers: request.headers,\n            },\n          });\n          response.cookies.set({ name, value: '', ...secureOptions });\n        },\n      },\n    }\n  );\n\n  return { supabase, response };\n}\n\n/**\n * Secure server-side user authentication\n * Returns user data if authenticated, null if not\n * Should be used in all server components requiring auth\n */\nexport async function getAuthenticatedUser() {\n  const supabase = createServerClient();\n  \n  try {\n    const { data: { user }, error } = await supabase.auth.getUser();\n    \n    if (error) {\n      console.warn('Authentication check failed:', error.message);\n      return null;\n    }\n    \n    // Additional validation: check if session is still valid\n    if (user) {\n      const { data: { session } } = await supabase.auth.getSession();\n      if (!session) {\n        console.warn('User found but no valid session');\n        return null;\n      }\n    }\n    \n    return user;\n  } catch (error) {\n    console.error('Error checking authentication:', error);\n    return null;\n  }\n}\n\n/**\n * Validate session and refresh if needed\n * Used in middleware for automatic token refresh\n */\nexport async function validateAndRefreshSession(request: NextRequest) {\n  const { supabase, response } = createMiddlewareClient(request);\n  \n  try {\n    // This will automatically refresh the session if needed\n    const { data: { user }, error } = await supabase.auth.getUser();\n    \n    if (error) {\n      console.warn('Session validation failed:', error.message);\n    }\n    \n    return { user, response, supabase };\n  } catch (error) {\n    console.error('Error validating session:', error);\n    return { user: null, response, supabase };\n  }\n}\n\n/**\n * OAuth configuration for Google and GitHub\n */\nexport const OAUTH_PROVIDERS = {\n  google: {\n    provider: 'google' as const,\n    options: {\n      redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/callback`,\n      scopes: 'openid email profile',\n      queryParams: {\n        access_type: 'offline',\n        prompt: 'consent',\n      },\n    },\n  },\n  github: {\n    provider: 'github' as const,\n    options: {\n      redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/callback`,\n      scopes: 'user:email',\n    },\n  },\n};\n\n/**\n * Initiate OAuth sign-in (client-side)\n */\nexport async function signInWithOAuth(provider: 'google' | 'github') {\n  const supabase = createBrowserClient();\n  const config = OAUTH_PROVIDERS[provider];\n  \n  try {\n    const { data, error } = await supabase.auth.signInWithOAuth(config);\n    \n    if (error) {\n      throw error;\n    }\n    \n    return { data, error: null };\n  } catch (error) {\n    console.error(`OAuth ${provider} sign-in error:`, error);\n    return { data: null, error };\n  }\n}\n\n/**\n * Secure sign out (clears all cookies and sessions)\n */\nexport async function signOut() {\n  const supabase = createBrowserClient();\n  \n  try {\n    const { error } = await supabase.auth.signOut();\n    \n    if (error) {\n      console.warn('Sign out error:', error.message);\n    }\n    \n    // Force reload to clear any remaining client state\n    window.location.href = '/auth/login';\n  } catch (error) {\n    console.error('Error during sign out:', error);\n    // Force redirect even if sign out fails\n    window.location.href = '/auth/login';\n  }\n}\n\n/**\n * Get user role/permissions (if you implement RBAC)\n */\nexport async function getUserRole(userId: string) {\n  const supabase = createServerClient();\n  \n  try {\n    // Example: Query user_roles table\n    const { data, error } = await supabase\n      .from('user_roles')\n      .select('role')\n      .eq('user_id', userId)\n      .single();\n    \n    if (error && error.code !== 'PGRST116') {\n      console.warn('Error fetching user role:', error.message);\n      return 'user'; // default role\n    }\n    \n    return data?.role || 'user';\n  } catch (error) {\n    console.error('Error checking user role:', error);\n    return 'user';\n  }\n}\n\n/**\n * Security middleware helper functions\n */\nexport const AuthSecurity = {\n  /**\n   * Check if request is from authenticated user\n   */\n  isAuthenticated: async (request: NextRequest): Promise<boolean> => {\n    const { user } = await validateAndRefreshSession(request);\n    return !!user;\n  },\n  \n  /**\n   * Redirect to login if not authenticated\n   */\n  requireAuth: (request: NextRequest, redirectTo: string = '/auth/login') => {\n    const url = request.nextUrl.clone();\n    url.pathname = redirectTo;\n    url.searchParams.set('redirect', request.nextUrl.pathname);\n    return NextResponse.redirect(url);\n  },\n  \n  /**\n   * Add security headers to response\n   */\n  addSecurityHeaders: (response: NextResponse) => {\n    response.headers.set('X-Frame-Options', 'DENY');\n    response.headers.set('X-Content-Type-Options', 'nosniff');\n    response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');\n    response.headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');\n    return response;\n  },\n};
